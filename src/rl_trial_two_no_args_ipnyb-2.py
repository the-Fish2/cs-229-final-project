# -*- coding: utf-8 -*-
"""RL_Trial_Two_No_Args.ipnyb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19cIgL_Td-3LEiSfM7tbQzn-TrG_nJ6rJ
"""

import numpy as np
import math
import gymnasium as gym
from gymnasium import spaces
import copy
from enum import Enum, auto

np.set_printoptions(precision=3, suppress=True)

np.random.seed(0)

class Function_Type(Enum):
    ROOT = auto()
    POW = auto()
    SUB = auto()
    ADD = auto()
    MUL = auto()
    DIV = auto()

    @property
    def inverse(self):
        """Simple inverse mapping."""
        return {
            Function_Type.POW: Function_Type.ROOT,
            Function_Type.SUB: Function_Type.ADD,
            Function_Type.MUL: Function_Type.DIV,
            Function_Type.DIV: Function_Type.MUL,
            Function_Type.ROOT: Function_Type.POW,
            Function_Type.ADD: Function_Type.SUB,
        }[self]

class func:
    def __init__(self, func_type: Function_Type, a: int, b: int, func_arg: int, sub_func = None, complexity: int = 0):
      self.a = a
      self.b = b
      self.func_arg = func_arg
      self.func = func_type
      self.sub_func = sub_func
      if sub_func:
        self.complexity = sub_func.complexity + 1
      else:
        self.complexity = 1

    def apply_function(self, func_applied: Function_Type, arg: float = None):

      self.a = float(self.a)
      self.b = float(self.b)

      if func_applied == Function_Type.SUB:
        self.b -= arg
      elif func_applied == Function_Type.ADD:
        self.b += arg
      elif func_applied == Function_Type.MUL:
        self.a *= arg
        self.b *= arg
      elif func_applied == Function_Type.DIV:
        self.a /= arg
        self.b /= arg
      elif func_applied == self.func.inverse and self.func_arg != 1:
        if (np.isclose(self.a, 1) and np.isclose(self.b, 0)):
          return self.sub_func
        else:
          new_func = func(func_applied, 1, 0, func_arg = arg, sub_func = self,) #this should be based on the input arguments
          return new_func #this function should point to the current function (implying we've added another layer to the function)
      else:
          new_func = func(func_applied, 1, 0, func_arg = arg, sub_func = self)
          return new_func

      return self

    def evaluate(self, x):
        if self.sub_func:
          inner_val = self.sub_func.evaluate(x)
        else:
          inner_val = x  # base variable

        if self.func == Function_Type.ROOT:
          val = np.sign(inner_val) * np.pow(np.abs(inner_val), 1/self.func_arg)
        elif self.func == Function_Type.POW:
          val = np.sign(inner_val) * np.pow(np.abs(inner_val), self.func_arg)

        val = self.a * val + self.b

        return val

    def __repr__(self):
      return f"{self.a} * {self.func}( {self.sub_func} )^{self.func_arg} + {self.b}"

def generate_samples(n=500, xmin=-10, xmax=10):
    """Generate n evenly spaced samples between xmin and xmax."""
    return np.linspace(xmin, xmax, n)

# Create a simple nested function: f(x) = 2 * SIN(3x + 1) - 4
inner = func(Function_Type.POW, 1, 2, func_arg = 1, complexity=1)  # 3x + 1
outer = func(Function_Type.POW, 1, 2, func_arg=3, sub_func = inner)
print(outer.complexity)
print(outer)
y = []
for x in xs:
  xs = generate_samples()
  y.append(outer.evaluate(x))
print(xs[:5], y[:5])

xs = generate_samples()
gen_func = func(Function_Type.POW, 1, 2, 3, complexity=2)

gen_func = gen_func.apply_function(Function_Type.ROOT, arg = 3)

gen_func.evaluate(xs)

gen_func.evaluate(xs)

gen_func = gen_func.apply_function(Function_Type.SUB, 2)

gen_func = gen_func.apply_function(Function_Type.MUL, 1)

gen_func = gen_func.apply_function(Function_Type.ROOT, 3)

print(gen_func)

class FunctionSimplificationEnv(gym.Env):
    """
    RL Environment for learning to simplify functions.

    Action Space:
        - Function type (6 options): ROOT, POW, SUB, ADD, MUL, DIV
        - Function argument for ROOT/POW: [1, 3, 5]
        - Argument for SUB/ADD/MUL/DIV: [1, 2, 3]

    Total actions: We'll use a discrete action space combining all possibilities
    - ROOT with arg [1,3,5]: 3 actions
    - POW with arg [1,3,5]: 3 actions
    - SUB with arg [1,2,3]: 3 actions
    - ADD with arg [1,2,3]: 3 actions
    - MUL with arg [1,2,3]: 3 actions
    - DIV with arg [1,2,3]: 3 actions
    Total: 18 actions

    Observation Space:
        - Current y-values from evaluating the function (500 samples)
        - Target y-values (x values, representing simplified function)
        - Steps remaining
        - Current complexity
    """

    def __init__(self, max_steps=6, max_complexity=3, n_samples=500):
        super(FunctionSimplificationEnv, self).__init__()

        self.max_steps = max_steps
        self.max_complexity = max_complexity
        self.n_samples = n_samples
        self.xs = generate_samples(n=n_samples)

        # Define action space
        # 18 discrete actions as described above
        self.action_space = spaces.Discrete(18)

        # Define observation space
        # Current function outputs + target outputs + metadata
        self.observation_space = spaces.Box(
            low=-np.inf,
            high=np.inf,
            shape=(n_samples * 2 + 2,),  # current y + target y + steps_remaining + complexity
            dtype=np.float32
        )

        # Action mapping
        self.action_map = self._create_action_map()

        self.reset()

    def _create_action_map(self):
        """Create mapping from action index to (function_type, argument)."""
        actions = []

        # ROOT with args [1, 3, 5]
        for arg in [1, 3, 5]:
            actions.append((Function_Type.ROOT, arg))

        # POW with args [1, 3, 5]
        for arg in [1, 3, 5]:
            actions.append((Function_Type.POW, arg))

        # SUB with args [1, 2, 3]
        for arg in [1, 2, 3]:
            actions.append((Function_Type.SUB, arg))

        # ADD with args [1, 2, 3]
        for arg in [1, 2, 3]:
            actions.append((Function_Type.ADD, arg))

        # MUL with args [1, 2, 3]
        for arg in [1, 2, 3]:
            actions.append((Function_Type.MUL, arg))

        # DIV with args [1, 2, 3]
        for arg in [1, 2, 3]:
            actions.append((Function_Type.DIV, arg))

        return actions

    def _generate_random_function(self):
        """Generate a random function with complexity between 1 and max_complexity."""
        complexity = 1 #np.random.randint(1, self.max_complexity + 1)

        # Start with identity: f(x) = x
        current_func = None

        for _ in range(complexity):
            # Choose random function type (only ROOT and POW for composability)
            func_type = np.random.choice([Function_Type.ROOT, Function_Type.POW])
            func_arg = np.random.choice([1, 3, 5])
            a = np.random.choice([1, 2, 3])
            b = np.random.choice([0, 1, 2, 3])  # Allow 0 for b

            current_func = func(func_type, a, b, func_arg, sub_func=current_func)

        return current_func

    def _get_observation(self):
        """Get current observation."""
        if self.current_func is None:
            current_y = self.xs
        else:
            current_y = self.current_func.evaluate(self.xs)
        target_y = self.xs  # Target is just x (fully simplified)

        obs = np.concatenate([
            current_y,
            target_y,
            [self.steps_remaining / self.max_steps],
            [self.current_func.complexity / self.max_complexity]
        ]).astype(np.float32)

        return obs

    def _compute_reward(self, prev_complexity, new_complexity, is_simplified):
        """Compute reward based on progress."""
        reward = 0

        # Large reward for complete simplification
        if is_simplified:
            reward += 100
            # Bonus for doing it quickly
            reward += self.steps_remaining * 10

        # Reward for reducing complexity
        elif new_complexity < prev_complexity:
            reward += 10 * (prev_complexity - new_complexity)

        # Small penalty for increasing complexity
        elif new_complexity > prev_complexity:
            reward -= 5 * (new_complexity - prev_complexity)

        # Small penalty for wasting a step
        else:
            reward -= 1

        return reward

    def _is_simplified(self):
        """Check if function is fully simplified (f(x) = x)."""
        try:
            # A simplified function should be: f(x) = x
            # This means no sub_func, a=1, b=0
            if self.current_func.sub_func is None:
                # Check if it evaluates to identity
                test_vals = self.current_func.evaluate(self.xs)
                if np.allclose(test_vals, self.xs, rtol=1e-3):
                    return True
            return False
        except:
            return False

    def reset(self, seed=None, options=None):
        """Reset the environment."""
        if seed is not None:
            np.random.seed(seed)

        self.target_func = self._generate_random_function()
        self.current_func = copy.deepcopy(self.target_func)
        self.steps_remaining = self.max_steps
        self.initial_complexity = self.current_func.complexity

        return self._get_observation(), {}

    def step(self, action):
        """Execute one step."""
        prev_complexity = self.current_func.complexity

        # Decode action
        func_type, arg = self.action_map[action]

        result = self.current_func.apply_function(func_type, arg)
        if result is not None:
            self.current_func = result

        self.steps_remaining -= 1

        # Check if simplified
        is_simplified = self._is_simplified()
        new_complexity = self.current_func.complexity

        # Compute reward
        reward = self._compute_reward(prev_complexity, new_complexity, is_simplified)

        # Check termination
        terminated = is_simplified or self.steps_remaining <= 0
        truncated = False

        obs = self._get_observation()
        info = {
            'complexity': new_complexity,
            'initial_complexity': self.initial_complexity,
            'is_simplified': is_simplified,
            'steps_used': self.max_steps - self.steps_remaining
        }

        return obs, reward, terminated, truncated, info

env = FunctionSimplificationEnv()

print("Testing environment with random actions...")
for episode in range(10000):
  obs, info = env.reset()
  print(f"\n=== Episode {episode + 1} ===")
  print(f"Initial function: {env.current_func}")
  print(f"Initial complexity: {env.current_func.complexity}")

  total_reward = 0
  done = False
  step = 0

  while not done:
      action = env.action_space.sample()
      func_type, arg = env.action_map[action]

      obs, reward, terminated, truncated, info = env.step(action)
      done = terminated or truncated
      total_reward += reward
      step += 1

      # print(f"\nStep {step}:")
      # print(f"  Action: {func_type.name} with arg {arg}")
      # print(f"  Current function: {env.current_func}")
      # print(f"  Target function: {env.target_func}")
      # print(f"  Observation space: {obs}")
      # print(f"  Complexity: {info['complexity']}")
      # print(f"  Reward: {reward:.2f}")
      # print(f"  Simplified: {info['is_simplified']}")

  print(f"\nEpisode finished!")
  print(f"Total reward: {total_reward:.2f}")
  print(f"Final complexity: {info['complexity']}")
  print(f"Successfully simplified: {info['is_simplified']}")
